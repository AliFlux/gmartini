package gmartini

import (
	"bufio"
	"encoding/binary"
	"image"
	_ "image/png"
	"io"
	"os"
	"testing"
)

// references
// [1] https://github.com/kylebarron/pymartini/blob/master/test/create_test_data.js

func TestTerrain(t *testing.T) {

	terrainFile := "../data/fuji.png"
	expectedTerrainFile := "../data/fuji_terrain" // generated by ref[1]
	encoding := "mapbox"
	var epsilon float32 = 100

	// generate terrain
	file1, err := os.Open(terrainFile)
	if err != nil {
		t.Error(err)
	}
	defer file1.Close()

	img, _, err := image.Decode(file1)
	if err != nil {
		t.Error(err)
	}

	terrain, err := DecodeElevations(img, encoding, true)
	if err != nil {
		t.Error(err)
	}

	// load expected terrain
	file2, err := os.Open(expectedTerrainFile)
	if err != nil {
		t.Error(err)
	}
	defer file2.Close()

	var expectedTerrain []float32
	reader := bufio.NewReader(file2)
	var i float32
	for {
		err := binary.Read(reader, binary.LittleEndian, &i)
		if err == io.EOF {
			break
		}
		expectedTerrain = append(expectedTerrain, i)
	}

	var max, min float32
	max, min = maxminFloat32(terrain)
	t.Logf("terrain: %f max, %f min", max, min)
	max, min = maxminFloat32(expectedTerrain)
	t.Logf("expected terrain: %f max, %f min", max, min)

	for i, v := range terrain {
		delta := v - expectedTerrain[i]
		if absFloat32(delta) > epsilon {
			t.Logf("terrain mismatch exceeding %f epsilon: calculated %f, expected %f (delta %f)", epsilon, v, expectedTerrain[i], delta)
		}
	}

	if !equalFloat32(terrain, expectedTerrain, epsilon) {
		t.Logf("terrain doesn't match expected at epsilon %f", epsilon)
		t.Fail()
	} else {
		t.Logf("terrain matches expected at epsilon %f", epsilon)
	}
}
